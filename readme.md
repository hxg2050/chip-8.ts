# javascript版 Chip-8 模拟器

参考：[https://en.wikipedia.org/wiki/CHIP-8#Opcode_table](https://en.wikipedia.org/wiki/CHIP-8#Opcode_table)  
C/C++版本参考: [https://github.com/dmatlack/chip8](https://github.com/dmatlack/chip8)  
下面是指令中文说明，我整理制作了一个表格，参考: [https://kaibaoom.tw/2019/07/22/chip8emu-instruction-set/](https://kaibaoom.tw/2019/07/22/chip8emu-instruction-set/)

------  

|       | 指令  | 说明                                                                                                                                                                                                                                                                                                                                           |
| :---: | :---: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|   1   | 0NNN  | 已不使用，Jump到某个Machine code程序中                                                                                                                                                                                                                                                                                                         |
|   2   | 00E0  | 清除画面 实际方法:请依据绘图引擎不同自行设计                                                                                                                                                                                                                                                                                                   |
|   3   | 00EE  | Return from a subroutine 实际方法:将Stack最上层的address放到ProgramCounter里，并将StackPointer减少一层                                                                                                                                                                                                                                         |
|   4   | 1NNN  | 跳到NNN这个address执行 实际方法: ProgramCounter <= NNN                                                                                                                                                                                                                                                                                         |
|   5   | 2NNN  | 呼叫NNN位址中的子程序 实际方法:将StackPointer增加1，并把目前的ProgramCounter放到Stack中，最后把ProgramCounter更改为NNN                                                                                                                                                                                                                         |
|   6   | 3XNN  | if Vx = kk, 跳过下一个指令 实际方法:比较Vx占存器所储存的值是否与常数NN相同，如果结果为真，就跳过一次Opcode                                                                                                                                                                                                                                     |
|   7   | 4XNN  | if Vx != kk, 跳过下一个指令 实际方法:比较Vx占存器所储存的值是否与常数NN相异，如果结果为真，就跳过一次Opcode                                                                                                                                                                                                                                    |
|   8   | 5XY0  | if Vx = Vy, 跳过下一个指令 实际方法:比较Vx占存器所储存的值是否与Vy占存器所储存的值相同，如果结果为真，就跳过一次Opcode                                                                                                                                                                                                                         |
|   9   | 6XNN  | 将Vx的值设为NN 实际方法: Vx <= NN                                                                                                                                                                                                                                                                                                              |
|  10   | 7XNN  | Vx的值加上NN之后，再放到Vx中 实际方法: Vx = Vx + NN                                                                                                                                                                                                                                                                                            |
|  11   | 8XY0  | Vy的值放到Vx 实际方法: Vx = Vy                                                                                                                                                                                                                                                                                                                 |
|  12   | 8XY1  | Vx与Vy的每个bit做OR位元运算 实际方法: Vx = Vx                                                                                                                                                                                                                                                                                                  | Vy |
|  13   | 8XY2  | Vx与Vy的每个bit做AND位元运算 实际方法: Vx = Vx & Vy                                                                                                                                                                                                                                                                                            |
|  14   | 8XY3  | Vx与Vy的每个bit做XOR位元运算 实际方法: Vx = Vx ^ Vy                                                                                                                                                                                                                                                                                            |
|  15   | 8XY4  | 将Vx的值设为Vx+Vy，若相加数值超过255则将VF(CarryFlag)设为1 实际方法: Vx = Vx + Vy, 若相加结果无法完整放于8bits中，则将VF设为1，并把低位元的8bits放到Vx中                                                                                                                                                                                       |
|  16   | 8XY5  | 将Vx的值设为Vx-Vy，若Vx>Vy则将VF设为1，否则为0 实际方法: Vx = Vx - Vy, 若Vx>Vy则将VF的值设为1，否则为0 ，并将相减结果存放至Vx中                                                                                                                                                                                                                |
|  17   | 8XY6  | 将Vx最大位元的数值放到VF中，并将Vx除以2 实际方法:将Vx最大位元放置VF中后，把Vx向右位移1bit                                                                                                                                                                                                                                                      |
|  18   | 8XY7  | 将Vx的值设为Vy-Vx，若Vy>Vx则将VF设为1，否则为0 实际方法: Vx = Vy - Vx, 若Vy>Vx则将VF的值设为1，否则为0 ，并将相减结果存放至Vx中                                                                                                                                                                                                                |
|  19   | 8XYE  | 将Vx最大位元的数值放到VF中，并将Vx乘以2 实际方法:将Vx最大位元放置VF中后，把Vx向右位移1bit                                                                                                                                                                                                                                                      |
|  20   | 9xy0  | if Vx != Vy 跳过下一个指令 实际方法:若Vx != Vy，则跳过一次Opcode                                                                                                                                                                                                                                                                               |
|  21   | ANNN  | 将I的值设为NNN 实际方法:恩…如上所述                                                                                                                                                                                                                                                                                                            |
|  22   | BNNN  | 程式跳至NNN+V0的位置执行 实际方法:将ProgramCounter的值设为NNN再加上暂存器V0的值                                                                                                                                                                                                                                                                |
|  23   | CXNN  | 随机产生一个8bits的数字与常数NN做AND运算，并值放置Vx中 实际方法:呼叫C语言中的乱数产生器产生0~255的数字，并透过8XY2的概念来执行AND运算，运算结果放到Vx的值中                                                                                                                                                                                    |
|  24   | DXYN  | 在(Vx, Vy)的座标上绘制一个从I所储存的位址开始n bytes的sprite，若画面有任何已存在的pixel被修改，则将VF设为1(CollisionFlag)实际方法: 从I所储存的位址开始以byte为单位绘制画面，每个pixel绘制之前都须与现有画面上的pixel做XOR运算(参阅8XY3 opcode)，若结果为真，则将VF值改为1否则为0 。详细绘制方法请参阅绘图引擎的相关文件。                      |
|  25   | Ex9E  | 若存放在Vx的KeyCode等于目前所按下的按键，则跳过下个Opcode 实际方法:检查目前按下的KeyCode是否等于Vx的值，若两值相等则将ProgramCounter加2                                                                                                                                                                                                        |
|  26   | EXA1  | 若存放在Vx的KeyCode目前没有被按下，则跳过下个Opcode 实际方法:检查Vx目前的KeyCode是否处于非按下的情况，若为非按下的情况则将ProgramCounter加2                                                                                                                                                                                                    |
|  27   | FX07  | Vx的值设为目前的Delay Time                                                                                                                                                                                                                                                                                                                     |
|  28   | Fx0A  | 等待按键输入，当任一按键触发时将其KeyCode存放至Vx中 实际方法:这是一个blocking的Opcode，会等待任一按键触发之后将其值存放至Vx当中                                                                                                                                                                                                                |
|  29   | FX15  | 将目前Delay Timer的值设为Vx所存放的值                                                                                                                                                                                                                                                                                                          |
|  30   | FX18  | 将目前Sound Timer的值设为Vx所存放的值                                                                                                                                                                                                                                                                                                          |
|  31   | FX1E  | 将I与Vx的值相加之后存放至I当中                                                                                                                                                                                                                                                                                                                 |
|  32   | FX29  | 将Vx的值对应到正确字型记忆体位置后存放到I 实际方法:第一次看到这个有点不解，举个范例来解释比较清楚，由于我们存放预设字型的位置是0x0000~ 0x0050，每个字各占5 bytes大小，假设Vx暂存器的值是3，那么它所对应的字型3记忆体位置应为0x000F开始，所以将0x000F放至I当中。简单来说因为每个字占5bytes而且又是从0开始，所以将Vx当中的值乘上5后即可存放至I。 |
|  33   | FX33  | 将Vx中的值转换成BCD表示法，并将结果分别存放至记忆体位址I(百位数字),I+1(十位数字),I+2(个位数)实际方法 : BCD转换不多谈，来说明一下I存放的方法，由于I存放的是记忆体位址，所以必须藉由memory[I]这样的存取方式存放值到记忆体当中。                                                                                                                  |
|  34   | FX55  | 俗称的register dump，把特定范围register所存放的值复制一份到从I开始的连续记忆体当中 实际方法: V0~Vx依序将值复制到I, I+1, I+2….V +x当中                                                                                                                                                                                                          |
|  35   | FX65  | 从I开始的memory当中依序取出值存放到register当中 实际方法: I, I+1, I+2….V+x依序将值复制到V0~Vx当中                                                                                                                                                                                                                                              |